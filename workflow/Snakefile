from pathlib import Path

configfile: "config/config.yaml"

def list_scans(root_folder, prefix):
    mapping = {}

    for path in Path(root_folder).iterdir():
        if not path.is_dir() and not path.suffix == ".zip":
            continue

        infos = [s.lower() for s in path.stem.replace(prefix, "").split("_")]
        if len(infos) == 2:
            infos += ["a"]

        cohort, subject, session = infos

        if path.is_dir():
            mapping[(cohort + subject, session)] = path
        else:
            mapping[(cohort + subject, session)] = path.with_suffix("")

    return mapping

MAPPING = list_scans(config["datadir"], config["ethics_prefix"])
SUBJECTS, SESSIONS = zip(*MAPPING)

rule all:
    input:
        expand(
            expand(
                "{{resultsdir}}/bids/derivatives/sub-{subject}_ses-{session}.done",
                zip,
                subject=SUBJECTS,
                session=SESSIONS,
            ),
            resultsdir=config["resultsdir"],
        )

rule unzip:
    input:
        expand("{datadir}/{{folder}}.zip", datadir=config['datadir'])
    output:
        directory(expand("{datadir}/{{folder}}", datadir=config['datadir']))
    shell:
        "unzip -q -d {output} {input}"

rule tidy_dicoms:
    input:
        lambda wildards: MAPPING[(wildards.subject, wildards.session)]
    output:
        directory("{resultsdir}/tidy/sub_{subject}/ses_{session}")
    run:
        output_folder = Path(output[0])
        for dicom_file in Path(input[0]).rglob("*.dcm"):
            target_folder = output_folder / dicom_file.parent.name
            target_folder.mkdir(parents=True, exist_ok=True)
            (target_folder / dicom_file.name).symlink_to(dicom_file)

checkpoint heudiconv:
    input:
        "{resultsdir}/tidy/sub_{subject}/ses_{session}"
    output:
        directory("{resultsdir}/bids/sub-{subject}/ses-{session}"),
        directory("{resultsdir}/bids/.heudiconv/{subject}/ses-{session}")
    container:
        "docker://ghcr.io/jennan/heudiconv:jpeg2000_ci"
    threads: config["heudiconv"]["threads"]
    resources:
        cpus=lambda wildcards, threads: threads,
        mem_mb=config["heudiconv"]["mem_mb"],
        time_min=config["heudiconv"]["time_min"]
    shell:
        "heudiconv "
        "--dicom_dir_template '{wildcards.resultsdir}/tidy/sub_{{subject}}/ses_{{session}}/*/*' "
        "--outdir {wildcards.resultsdir}/bids "
        "--heuristic {config[heudiconv][heuristic]} "
        "--subjects {wildcards.subject} "
        "--ses {wildcards.session} "
        "--converter dcm2niix "
        "--bids "
        "--overwrite"

def hd_bet_output(wildcards, output):
    output_nifti = Path(output["brain"])
    output_prefix = output_nifti.stem.split(".")[0]
    return output_nifti.parent / output_prefix

rule hd_bet:
    input:
        "{resultsdir}/bids/sub-{subject}/ses-{session}"
    output:
        brain="{resultsdir}/bids/derivatives/hd_bet/sub-{subject}/ses-{session}/sub-{subject}_ses-{session}_{entity}_T1w_brain.nii.gz",
        mask="{resultsdir}/bids/derivatives/hd_bet/sub-{subject}/ses-{session}/sub-{subject}_ses-{session}_{entity}_T1w_brain_mask.nii.gz"
    conda:
        "envs/hd_bet.yaml"
    params:
        output=hd_bet_output
    threads: config["hd_bet"]["threads"]
    resources:
        cpus=lambda wildcards, threads: threads,
        mem_mb=config["hd_bet"]["mem_mb"],
        time_min=config["hd_bet"]["time_min"]
    shell:
        "hd-bet -i {input}/anat/sub-{wildcards.subject}_ses-{wildcards.session}_{wildcards.entity}_T1w.nii.gz "
        "-o {params.output} "
        "-tta 0 -mode fast -device cpu"

rule convert_pre_denoise:
    input:
        "{resultsdir}/bids/sub-{subject}/ses-{session}"
    output:
        "{resultsdir}/bids/derivatives/dwi_preprocessing/sub-{subject}/ses-{session}/dwi/sub-{subject}_ses-{session}_{entity}_dwi.mif"
    container:
        "docker://mrtrix3/mrtrix3:3.0.4"
    shell:
        "mrconvert {input}/dwi/sub-{wildcards.subject}_ses-{wildcards.session}_{wildcards.entity}_dwi.nii.gz "
        "-fslgrad {input}/dwi/sub-{wildcards.subject}_ses-{wildcards.session}_{wildcards.entity}_dwi.bvec "
        "{input}/dwi/sub-{wildcards.subject}_ses-{wildcards.session}_{wildcards.entity}_dwi.bval "
        "{output}"

rule denoise:
    input:
        "{derivatives}/sub-{subject}_ses-{session}_{entity}_dwi.mif",
    output:
        denoised="{derivatives}/sub-{subject}_ses-{session}_{entity}_dwi_denoise.mif",
        noise="{derivatives}/sub-{subject}_ses-{session}_{entity}_noise.mif"
    container:
        "docker://mrtrix3/mrtrix3:3.0.4"
    threads: config["denoise"]["threads"]
    resources:
        cpus=lambda wildcards, threads: threads,
        mem_mb=config["denoise"]["mem_mb"],
        time_min=config["denoise"]["time_min"]
    shell:
        "dwidenoise -nthreads {threads} {input} {output.denoised} -noise {output.noise}"

rule fslroi:
    input:
        "{resultsdir}/bids/sub-{subject}/ses-{session}"
    output:
        "{resultsdir}/bids/derivatives/dwi_preprocessing/sub-{subject}/ses-{session}/dwi/sub-{subject}_ses-{session}_{entity}_nodif.nii.gz"
    conda:
        "envs/fsl.yaml"
    shell:
        "export FSLDIR=$(dirname $(which fslroi))/.. && "
        ". ${{FSLDIR}}/etc/fslconf/fsl.sh && "
        "fslroi {input}/dwi/sub-{wildcards.subject}_ses-{wildcards.session}_{wildcards.entity}_dwi.nii.gz "
        "{output} 0 1"

rule bet:
    input:
        "{derivatives}/sub-{subject}_ses-{session}_{entity}_nodif.nii.gz"
    output:
        "{derivatives}/sub-{subject}_ses-{session}_{entity}_dwi_brain_mask.nii.gz"
    conda:
        "envs/fsl.yaml"
    shell:
        "export FSLDIR=$(dirname $(which bet))/.. && "
        ". ${{FSLDIR}}/etc/fslconf/fsl.sh && "
        "bet {input} {output}"

rule convert_post_bet:
    input:
        "{derivatives}/sub-{subject}_ses-{session}_{entity}_dwi_brain_mask.nii.gz"
    output:
        "{derivatives}/sub-{subject}_ses-{session}_{entity}_dwi_mask.mif"
    container:
        "docker://mrtrix3/mrtrix3:3.0.4"
    shell:
        "mrconvert {input} {output}"

rule bias_correction:
    message: "Bias field correction"
    input:
        data="{derivatives}/sub-{subject}_ses-{session}_{entity}_dwi_denoise.mif",
        mask="{derivatives}/sub-{subject}_ses-{session}_{entity}_dwi_mask.mif",
    output:
        debiased="{derivatives}/sub-{subject}_ses-{session}_{entity}_dwidnbc.mif",
        bias="{derivatives}/sub-{subject}_ses-{session}_{entity}_bias.mif"
    container:
        "docker://mrtrix3/mrtrix3:3.0.4"
    shell:
        "dwibiascorrect fsl {input.data} {output.debiased} -mask {input.mask} -bias {output.bias}"

rule ringing_correction:
    message: "Ringing artifact correction"
    input:
        "{derivatives}/sub-{subject}_ses-{session}_{entity}_dwidnbc.mif"
    output:
        "{derivatives}/sub-{subject}_ses-{session}_{entity}_dwidnbcdegibbs.mif"
    container:
        "docker://mrtrix3/mrtrix3:3.0.4"
    threads: config["ringing_correction"]["threads"]
    resources:
        cpus=lambda wildcards, threads: threads,
        mem_mb=config["ringing_correction"]["mem_mb"],
        time_min=config["ringing_correction"]["time_min"]
    shell:
        "mrdegibbs -nthreads {threads} {input} {output}"

rule convert_post_ringing:
    input:
        "{derivatives}/sub-{subject}_ses-{session}_{entity}_dwidnbcdegibbs.mif"
    output:
        "{derivatives}/sub-{subject}_ses-{session}_{entity}_dwidnbcdg.nii.gz"
    container:
        "docker://mrtrix3/mrtrix3:3.0.4"
    shell:
        "mrconvert {input} {output}"

def get_derivatives_filenames(wildcards):
    # create a dependency on heudiconv rule output
    checkpoints.heudiconv.get(**wildcards)

    bids_pattern = (
        f"{wildcards.resultsdir}/bids/sub-{wildcards.subject}/ses-{wildcards.session}"
        f"/anat/sub-{wildcards.subject}_ses-{wildcards.session}_"
        "{entity}_T1w.nii.gz"
    )
    entities, = glob_wildcards(bids_pattern)

    # TODO add all derivatives files to generate
    filenames_pattern = [
        "{resultsdir}/bids/derivatives/dwi_preprocessing/sub-{subject}/ses-{session}"
        "/dwi/sub-{subject}_ses-{session}_{entity}_dwidnbcdg.nii.gz",
        "{resultsdir}/bids/derivatives/hd_bet/sub-{subject}/ses-{session}/"
        "sub-{subject}_ses-{session}_{entity}_T1w_brain.nii.gz"
    ]

    filenames = expand(filenames_pattern, entity=entities, **wildcards)

    return filenames

rule all_derivatives:
    input:
        get_derivatives_filenames
    output:
        touch("{resultsdir}/bids/derivatives/sub-{subject}_ses-{session}.done")

# TODO convert as a rule
# singularity run -e \
# -B /eresearch/resmed/mtay316/DTI/Concussion_Phase2/Preseason/Processing/b0_synth/INPUTS/Pre_{subject}:/INPUTS \
# -B /eresearch/resmed/mtay316/DTI/Concussion_Phase2/Preseason/Processing/b0_synth/OUTPUTS/Pre_{subject}:/OUTPUTS \
# -B /eresearch/resmed/mtay316/DTI/Concussion_Phase2/Preseason/Processing/b0_synth/license.txt:/extra/freesurfer/license.txt \
# /hpc/mtay316/B0_synth/synb0-disco_v3.0.sif

# NOTE: Remember to put the index.txt and acqparams.txt files in the right folder

# TODO convert as a rule
# echo "Eddy current correction"
# scp DWI_W_pre/sub-{subject}_ses-{session}_Pre/index.txt BIDS_Processing/Pre_{subject}
#eddy_cuda9.1 --imain=bids/derivatives/dwi_preprocessing/sub-{subject}/ses-{session}/dwi/sub-{subject}_ses-{session}_dwidnbcdg.nii.gz --mask=bids/derivatives/dwi_preprocessing/sub-{subject}/ses-{session}/dwi/dwi_brain_mask_{subject} --index=bids/derivatives/dwi_preprocessing/sub-{subject}/ses-{session}/dwi/index.txt --acqp=b0_synth/INPUTS/acqparams.txt --bvecs=bids/sub-{subject}/ses-{session}/dwi/sub-{subject}_ses-{session}_dwi.bvec --bvals=bids/sub-{subject}/ses-{session}/dwi/sub-{subject}_ses-{session}_dwi.bval --fwhm=0 --topup=b0_synth/OUTPUTS/Pre_{subject}/topup --flm=quadratic --cnr_maps --out=bids/derivatives/dwi_preprocessing/sub-{subject}/ses-{session}/dwi/eddy_unwarped_{subject} --repol --mporder=6 -v
